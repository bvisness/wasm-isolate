package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/bvisness/wasm-isolate/utils"
	"github.com/spf13/cobra"
	tree_sitter "github.com/tree-sitter/go-tree-sitter"
	tree_sitter_ocaml "github.com/tree-sitter/tree-sitter-ocaml/bindings/go"
)

var specpath = filepath.Join("gen", "spec")

var source []byte
var outFile *os.File
var switchDepth int

func main() {
	var rootCmd *cobra.Command
	rootCmd = &cobra.Command{
		Use: "gen",
		Run: func(cmd *cobra.Command, args []string) {
			source = utils.Must1(os.ReadFile(filepath.Join(specpath, "interpreter", "binary", "decode.ml")))
			outFile = utils.Must1(os.Create("generated.go"))
			defer outFile.Close()

			w("// This file is automatically generated. DO NOT EDIT.\n")
			w("package parser\n\n")

			ocaml := tree_sitter.NewLanguage(tree_sitter_ocaml.LanguageOCaml())
			parser := tree_sitter.NewParser()
			defer parser.Close()
			parser.SetLanguage(ocaml)

			tree := parser.Parse(source, nil)
			defer tree.Close()

			root := tree.RootNode()
			cur := root.Walk()

			// Find `let rec instr s = ...`, the instruction-parsing function.
			var instr *tree_sitter.Node
			for _, child := range root.NamedChildren(cur) {
				if child.GrammarName() != "value_definition" {
					continue
				}
				binding := child.NamedChild(0)
				if binding.GrammarName() != "let_binding" {
					continue
				}
				pattern := binding.ChildByFieldName("pattern")
				if s(pattern) != "instr" {
					continue
				}

				instr = &child
				break
			}
			if instr == nil {
				exitWithError("Couldn't find `let rec instr s ...`")
			}

			parseFunc(instr)
		},
	}

	utils.Must(rootCmd.Execute())
}

func s(n *tree_sitter.Node) string {
	return n.Utf8Text(source)
}

func parseFunc(f *tree_sitter.Node) {
	utils.Assert(f.GrammarName() == "value_definition", "expected a let")
	cur := f.Walk()

	binding := Lookup{f}.Child(0, "let_binding").Node
	pattern := Lookup{binding}.Field("pattern", "").Node
	body := Lookup{binding}.Field("body", "").Node
	var params []*tree_sitter.Node
	for _, child := range binding.NamedChildren(cur) {
		if child.GrammarName() == "parameter" {
			params = append(params, &child)
		}
	}

	name := s(pattern)
	funcTypes := types[name]

	w("func %s(", funcName(s(pattern), len(params)))
	for _, param := range params {
		paramName := safeName(s(param))
		w("%s %s, ", paramName, funcTypes[s(param)])
	}
	w(") %s {\n", funcTypes[ret])

	parseExpr(body)

	w("}\n\n")
}

var reUnsafeChar = regexp.MustCompile("[^a-zA-Z0-9_]")

func safeName(name string) string {
	return "_" + reUnsafeChar.ReplaceAllString(name, "_")
}

func funcName(name string, numArgs int) string {
	name = safeName(name)
	if numArgs > 1 {
		name += fmt.Sprintf("_%d", numArgs)
	}
	return name
}

func parseExpr(expr *tree_sitter.Node) {
	switch expr.GrammarName() {
	case "value_path", "constructor_path", "_lowercase_identifier":
		name := reUnsafeChar.ReplaceAllString(s(expr), "_")
		w("_%s", name)
	case "number":
		n := s(expr)
		n = strings.TrimRight(n, "lL")
		w("%s", n)
	case "or_pattern", "tuple_pattern":
		parseExpr(expr.NamedChild(0))
		w(", ")
		parseExpr(expr.NamedChild(1))
	case "add_operator", "mult_operator", "rel_operator":
		// TODO: Implement more of these:
		// https://ocaml.org/manual/5.3/expr.html
		switch s(expr) {
		case "=":
			w("==")
		case "land":
			w("&")
		default:
			w(" %s ", s(expr))
		}
	case "string":
		w("%s", s(expr))

	case "application_expression":
		function := expr.ChildByFieldName("function")
		args := expr.ChildrenByFieldName("argument", expr.Walk())
		w("%s(", funcName(s(function), len(args)))
		for _, arg := range args {
			parseExpr(&arg)
			w(", ")
		}
		w(")")
	case "if_expression":
		condition := expr.ChildByFieldName("condition")

		w("if ")
		parseExpr(condition)

		for _, child := range expr.NamedChildren(expr.Walk()) {
			if child.Id() == condition.Id() {
				continue
			}

			switch child.GrammarName() {
			case "then_clause":
				w(" {\n")
				parseExpr(child.NamedChild(0))
				w("} ")
			case "else_clause":
				w(" else {\n")
				parseExpr(child.NamedChild(0))
				w("} ")
			default:
				exitWithError("unknown type in if expression: %s", child.GrammarName())
			}
		}

		w("\n")
	case "infix_expression":
		left := expr.ChildByFieldName("left")
		operator := expr.ChildByFieldName("operator")
		right := expr.ChildByFieldName("right")

		parseExpr(left)
		parseExpr(operator)
		parseExpr(right)
	case "let_expression":
		binding := Lookup{expr}.
			Child(0, "value_definition").
			Child(0, "let_binding").
			Node
		pattern := Lookup{binding}.Field("pattern", "").Node
		body := Lookup{binding}.Field("body", "").Node

		parseExpr(pattern)
		w(" := ")
		parseExpr(body)
		w("\n")

		parseExpr(expr.NamedChild(1))
	case "list_expression":
		w("nil /* TODO: list_expression */")
	case "match_expression":
		w("switch __switchVal%d := ", switchDepth)
		parseExpr(expr.NamedChild(0))
		w("; __switchVal%d {\n", switchDepth)

		for _, matchCase := range expr.NamedChildren(expr.Walk())[1:] {
			if matchCase.GrammarName() != "match_case" {
				continue
			}

			pattern := Lookup{&matchCase}.Field("pattern", "").Node
			body := Lookup{&matchCase}.Field("body", "").Node

			switch pattern.GrammarName() {
			case "number":
				w("case ")
				parseExpr(pattern)
				w(":\n")
			case "alias_pattern":
				w("case ")
				parseExpr(pattern.NamedChild(0))
				w(":\n")

				parseExpr(pattern.NamedChild(1))
				w(" := __switchVal%d\n", switchDepth)
			case "_lowercase_identifier":
				w("default:\n")
				w("%s := __switchVal%d\n", s(pattern), switchDepth)
			default:
				exitWithError("unknown type of match case: %s", pattern.GrammarName())
			}

			switchDepth++
			parseExpr(body)
			switchDepth--

			w("\n")
		}

		w("}\n")
	case "parenthesized_expression":
		// w("(")
		parseExpr(expr.NamedChild(0))
		// w(")")
	case "product_expression":
		w("nil /* TODO: product_expression */")
	case "sequence_expression":
		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		parseExpr(left)
		w("\n")
		parseExpr(right)
		w("\n")
	default:
		fmt.Fprintf(os.Stderr, "%s\n", s(expr))
		fmt.Fprintf(os.Stderr, "%s\n", expr.ToSexp())
		exitWithError("unknown expression type %s", expr.GrammarName())
	}
}

func w(msg string, args ...any) {
	fmt.Fprintf(outFile, msg, args...)
}

func exitWithError(msg string, args ...any) {
	msg = fmt.Sprintf(msg, args...)
	fmt.Fprintf(os.Stderr, "ERROR: %s\n", msg)
	os.Exit(1)
}

type Lookup struct {
	Node *tree_sitter.Node
}

func (l Lookup) Child(i uint, grammarName string) Lookup {
	node := l.Node.NamedChild(i)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}

func (l Lookup) Field(fieldName string, grammarName string) Lookup {
	node := l.Node.ChildByFieldName(fieldName)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}

const ret = "__ret"

var types = map[string]map[string]string{
	"instr": {
		"s": "*Stream",
		ret: "",
	},
}
