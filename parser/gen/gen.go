package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/bvisness/wasm-isolate/utils"
	"github.com/spf13/cobra"
	tree_sitter "github.com/tree-sitter/go-tree-sitter"
	tree_sitter_ocaml "github.com/tree-sitter/tree-sitter-ocaml/bindings/go"
)

var specpath = filepath.Join("gen", "spec")

const ret = "__ret"

var funcTypes = map[string]map[string][]string{
	"memop": {
		"s": {"*Stream"},
		ret: {"*Phrase[int]", "int", "int"},
	},
	"instr": {
		"s": {"*Stream"},
		ret: {"*Instr"},
	},
}
var funcsToTranslate = []string{
	"memop", "instr",
}

var actuallyInfix = map[string]string{
	"I32.lt_u":     "<",
	"Int32.logand": "&",
}

var source []byte
var outFile *os.File
var tmpCount int

func main() {
	var rootCmd *cobra.Command
	rootCmd = &cobra.Command{
		Use: "gen",
		Run: func(cmd *cobra.Command, args []string) {
			source = utils.Must1(os.ReadFile(filepath.Join(specpath, "interpreter", "binary", "decode.ml")))
			outFile = utils.Must1(os.Create("generated.go"))
			defer outFile.Close()

			w("// This file is automatically generated. DO NOT EDIT.\n")
			w("package parser\n\n")

			ocaml := tree_sitter.NewLanguage(tree_sitter_ocaml.LanguageOCaml())
			parser := tree_sitter.NewParser()
			defer parser.Close()
			parser.SetLanguage(ocaml)

			tree := parser.Parse(source, nil)
			defer tree.Close()

			root := tree.RootNode()
			cur := root.Walk()

			// Find and parse functions in our map
			for _, child := range root.NamedChildren(cur) {
				if child.GrammarName() != "value_definition" {
					continue
				}
				binding := child.NamedChild(0)
				if binding.GrammarName() != "let_binding" {
					continue
				}
				pattern := binding.ChildByFieldName("pattern")
				if slices.Contains(funcsToTranslate, s(pattern)) {
					parseFunc(&child)
				}
			}
		},
	}

	utils.Must(rootCmd.Execute())
}

func s(n *tree_sitter.Node) string {
	return n.Utf8Text(source)
}

func parseFunc(f *tree_sitter.Node) {
	fmt.Fprintf(os.Stderr, "%s\n", f.ToSexp())
	utils.Assert(f.GrammarName() == "value_definition", "expected a let")
	cur := f.Walk()

	binding := Lookup{f}.Child(0, "let_binding").Node
	pattern := Lookup{binding}.Field("pattern", "").Node
	body := Lookup{binding}.Field("body", "").Node
	var params []*tree_sitter.Node
	for _, child := range binding.NamedChildren(cur) {
		if child.GrammarName() == "parameter" {
			params = append(params, &child)
		}
	}

	name := s(pattern)
	funcTypes := funcTypes[name]

	tmpCount = 0

	w("func %s(", funcName(s(pattern), len(params)))
	for _, param := range params {
		paramName := safeName(s(param))
		w("%s %s, ", paramName, funcTypes[s(param)][0])
	}
	w(") (")
	for _, t := range funcTypes[ret] {
		w("%s, ", t)
	}
	w(") {\n")

	parseExpr(body, funcTypes[ret], true, true)

	w("}\n\n")
}

var reUnsafeChar = regexp.MustCompile("[^a-zA-Z0-9_]")

func safeName(name string) string {
	return "_" + reUnsafeChar.ReplaceAllString(name, "_")
}

func funcName(name string, numArgs int) string {
	name = safeName(name)
	if numArgs > 1 {
		name += fmt.Sprintf("_%d", numArgs)
	}
	return name
}

func parseExpr(expr *tree_sitter.Node, expectedType []string, statement bool, returnIfTerminal bool) []string {
	fmt.Fprintf(os.Stderr, "parsing %s (expecting: %s, as statement: %v, returning if terminal: %v)\n", expr.GrammarName(), expectedType, statement, returnIfTerminal)

	if returnIfTerminal && !statement {
		exitWithError("for %s expression: cannot return a non-statement", expr.GrammarName())
	}

	switch expr.GrammarName() {
	case "value_path", "constructor_path", "_lowercase_identifier":
		res := tmpVar()
		if statement {
			w("%s := ", res)
		}
		name := safeName(s(expr))
		w("%s", name)
		if statement {
			w("\n")
			if returnIfTerminal {
				w("return %s\n", res)
				return nil
			}
			return []string{res}
		}
	case "number":
		n := s(expr)
		n = strings.TrimRight(n, "lL")
		w("%s", n)
	case "or_pattern", "tuple_pattern":
		parseExpr(expr.NamedChild(0), nil, false, false)
		w(", ")
		parseExpr(expr.NamedChild(1), nil, false, false)
	case "add_operator", "mult_operator", "rel_operator", "concat_operator":
		// TODO: Implement more of these:
		// https://ocaml.org/manual/5.3/expr.html
		switch s(expr) {
		case "=":
			w("==")
		case "<>":
			w("!=")
		case "land":
			w("&")
		default:
			w(" %s ", s(expr))
		}
	case "string":
		w("%s", s(expr))

	case "application_expression":
		function := expr.ChildByFieldName("function")
		args := expr.ChildrenByFieldName("argument", expr.Walk())

		// if expectedType == nil {
		// 	if t, ok := funcTypes[s(function)]; ok {
		// 		expectedType = t[ret]
		// 	}
		// }

		results := resultVars(expectedType)
		if statement {
			w("%s := ", strings.Join(results, ", "))
		}

		if infixOp, ok := actuallyInfix[s(function)]; ok {
			w("(")
			parseExpr(&args[0], nil, false, false)
			w(")%s(", infixOp)
			parseExpr(&args[1], nil, false, false)
			w(")")
		} else {
			w("%s(", funcName(s(function), len(args)))
			for _, arg := range args {
				parseExpr(&arg, nil, false, false)
				w(", ")
			}
			w(")")
		}

		if statement {
			w("\n")
		}
		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else if statement {
			return results
		} else {
			return nil
		}
	case "if_expression":
		if !statement {
			exitWithError("cannot use if_expression as expression")
		}

		condition := expr.ChildByFieldName("condition")

		results := resultVars(expectedType)
		for i, res := range results {
			expected := "any"
			if i < len(expectedType) {
				expected = expectedType[i]
			}
			w("var %s %s\n", res, expected)
		}
		w("if ")
		parseExpr(condition, nil, false, false)
		for _, child := range expr.NamedChildren(expr.Walk()) {
			if child.Id() == condition.Id() {
				continue
			}

			switch child.GrammarName() {
			case "then_clause":
				w(" {\n")
				thenRes := parseExpr(child.NamedChild(0), expectedType, true, false)
				w("%s = %s", strings.Join(results, ", "), strings.Join(thenRes, ", "))
				w("} ")
			case "else_clause":
				w(" else {\n")
				elseRes := parseExpr(child.NamedChild(0), expectedType, true, false)
				w("%s = %s", strings.Join(results, ", "), strings.Join(elseRes, ", "))
				w("} ")
			default:
				exitWithError("unknown type in if expression: %s", child.GrammarName())
			}
		}
		w("\n")

		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else {
			return results
		}
	case "infix_expression":
		left := expr.ChildByFieldName("left")
		operator := expr.ChildByFieldName("operator")
		right := expr.ChildByFieldName("right")

		results := resultVars(expectedType)
		if statement {
			if expectedType != nil {
				w("/* %s */ ", strings.Join(expectedType, ", "))
			}
			w("%s := ", strings.Join(results, ", "))
		}

		if s(operator) == "@@" {
			// Super jank operator overload:
			// val (@@) : 'a -> region -> 'a phrase
			w("_operatorAtAt_2(")
			parseExpr(left, nil, false, false)
			w(", ")
			parseExpr(right, nil, false, false)
			w(")")
		} else {
			parseExpr(left, nil, false, false)
			parseExpr(operator, nil, false, false)
			parseExpr(right, nil, false, false)
		}

		if statement {
			w("\n")
		}

		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else if statement {
			return results
		} else {
			return nil
		}
	case "let_expression":
		if !statement {
			exitWithError("cannot use let_expression as an expression")
		}

		binding := Lookup{expr}.
			Child(0, "value_definition").
			Child(0, "let_binding").
			Node
		pattern := Lookup{binding}.Field("pattern", "").Node
		body := Lookup{binding}.Field("body", "").Node

		numResults := numValues(pattern)
		var phonyExpectedTypes []string
		for range numResults {
			phonyExpectedTypes = append(phonyExpectedTypes, "phony")
		}

		bindingRes := parseExpr(body, phonyExpectedTypes, true, false)

		parseExpr(pattern, nil, false, false)
		w(" := %s\n", strings.Join(bindingRes, ", "))

		return parseExpr(expr.NamedChild(1), expectedType, true, returnIfTerminal)
	case "list_expression":
		w("nil /* TODO: list_expression */")
	case "local_open_expression":
		// e.g. "Source.(0l @@ no_region)"
		return parseExpr(expr.NamedChild(1), expectedType, statement, returnIfTerminal)
	case "match_expression":
		switchResults := resultVars(expectedType)
		for i, t := range expectedType {
			w("var %s %s\n", switchResults[i], t)
		}

		switchVar := tmpVar()
		w("switch %s := ", switchVar)
		parseExpr(expr.NamedChild(0), nil, false, false)
		w("; %s {\n", switchVar)

		for _, matchCase := range expr.NamedChildren(expr.Walk())[1:] {
			if matchCase.GrammarName() != "match_case" {
				continue
			}

			pattern := Lookup{&matchCase}.Field("pattern", "").Node
			body := Lookup{&matchCase}.Field("body", "").Node

			switch pattern.GrammarName() {
			case "number":
				w("case ")
				parseExpr(pattern, nil, false, false)
				w(":\n")
			case "alias_pattern":
				w("case ")
				parseExpr(pattern.NamedChild(0), nil, false, false)
				w(":\n")

				parseExpr(pattern.NamedChild(1), nil, false, false)
				w(" := %s\n", switchVar)
			case "_lowercase_identifier":
				w("default:\n")
				w("%s := %s\n", s(pattern), switchVar)
			default:
				exitWithError("unknown type of match case: %s", pattern.GrammarName())
			}

			res := parseExpr(body, expectedType, true, false)
			w("%s = %s", strings.Join(switchResults, ", "), strings.Join(res, ", "))

			w("\n")
		}

		w("}\n")

		if returnIfTerminal {
			w("return %s\n", strings.Join(switchResults, ", "))
			return nil
		} else {
			return switchResults
		}
	case "parenthesized_expression":
		// w("(")
		return parseExpr(expr.NamedChild(0), expectedType, statement, returnIfTerminal)
		// w(")")
	case "product_expression":
		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		if returnIfTerminal {
			w("return ")
		}

		parseExpr(left, nil, false, false)
		w(", ")
		parseExpr(right, nil, false, false)
	case "sequence_expression":
		if !statement {
			exitWithError("cannot use sequence_expression as an expression")
		}

		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		leftRes := parseExpr(left, nil, true, false)
		ignores := make([]string, len(leftRes))
		for i := range len(leftRes) {
			ignores[i] = "_"
		}
		w("%s = %s\n", strings.Join(ignores, ", "), strings.Join(leftRes, ", "))

		rightRes := parseExpr(right, expectedType, true, returnIfTerminal)
		w("\n")

		return rightRes
	default:
		fmt.Fprintf(os.Stderr, "%s\n", s(expr))
		fmt.Fprintf(os.Stderr, "%s\n", expr.ToSexp())
		exitWithError("unknown expression type %s", expr.GrammarName())
	}

	return nil
}

func w(msg string, args ...any) {
	fmt.Fprintf(outFile, msg, args...)
}

func tmpVar() string {
	tmpCount += 1
	return fmt.Sprintf("__tmp%d", tmpCount)
}

func resultVars(expectedType []string) []string {
	if len(expectedType) == 0 {
		return []string{tmpVar()}
	} else {
		vars := make([]string, len(expectedType))
		for i := range len(expectedType) {
			vars[i] = tmpVar()
		}
		return vars
	}
}

func numValues(pattern *tree_sitter.Node) int {
	switch pattern.GrammarName() {
	case "tuple_pattern":
		return numValues(pattern.NamedChild(0)) + numValues(pattern.NamedChild(1))
	default:
		return 1
	}
}

func exitWithError(msg string, args ...any) {
	msg = fmt.Sprintf(msg, args...)
	fmt.Fprintf(os.Stderr, "ERROR: %s\n", msg)
	os.Exit(1)
}

type Lookup struct {
	Node *tree_sitter.Node
}

func (l Lookup) Child(i uint, grammarName string) Lookup {
	node := l.Node.NamedChild(i)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}

func (l Lookup) Field(fieldName string, grammarName string) Lookup {
	node := l.Node.ChildByFieldName(fieldName)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}
