package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/bvisness/wasm-isolate/parser/gen/ocaml"
	"github.com/bvisness/wasm-isolate/utils"
	"github.com/spf13/cobra"
	tree_sitter "github.com/tree-sitter/go-tree-sitter"
	tree_sitter_ocaml "github.com/tree-sitter/tree-sitter-ocaml/bindings/go"
)

var specpath = filepath.Join("gen", "spec")

var funcsToTranslate = []string{
	// Generic values
	"bit", "byte", "word16", "word32", "word64",
	"uN", "sN", "u32", "u64", "s7", "s32", "s33", "s64", "f32", "f64", /*"v128",*/
	"len32", "string",

	// Instructions
	"op", "end", "memop",
	"block_type", "local",
	"instr",
}

func ocaml2go_(t string) string {
	m := map[string]string{
		"bool":   "bool",
		"string": "string",

		"int":   "OInt",
		"int32": "OInt32",
		"int64": "OInt64",
		"F32.t": "float32",
		"F64.t": "float64",

		"address":   "OInt64",
		"type_idx":  "OInt32",
		"local_idx": "OInt32",

		"block_type": "BlockType",
		"heap_type":  "HeapType",
		"ref_type":   "RefType",
		"null":       "Null",

		"idx":    "*Phrase[OInt32]",
		"instr'": "Instruction_",
		"instr":  "*Phrase[Instruction_]",
		"local'": "Local_",
		"local":  "*Phrase[Local_]",

		"stream": "*Stream",
	}

	parts := strings.Split(t, " ")
	switch parts[len(parts)-1] {
	case "list":
		return fmt.Sprintf("[]%s", ocaml2go_(strings.Join(parts[:len(parts)-1], " ")))
	case "phrase":
		return fmt.Sprintf("*Phrase[%s]", ocaml2go_(strings.Join(parts[:len(parts)-1], " ")))
	case "option":
		return fmt.Sprintf("*%s", ocaml2go_(strings.Join(parts[:len(parts)-1], " ")))
	}

	if goType, ok := m[t]; ok {
		return goType
	} else {
		return fmt.Sprintf("TODO /* %s */", t)
	}
}

func ocaml2go(t ocaml.Type) string {
	return ocaml2go_(t.String())
}

var opNames = map[string]string{
	"@@": "AtAt",
	"+":  "Plus",
	"-":  "Minus",
	"=":  "Eq",
	"<>": "NotEq",
	">":  "Gt",
	"<":  "Lt",
	">=": "Gte",
	"<=": "Lte",
	"||": "Or",
}

var outFile *os.File
var tmpCount int

var lspClient *ocaml.Client
var ocamlParser *tree_sitter.Parser
var typeDefs = make(map[string]ocaml.Type)

func init() {
	lang := tree_sitter.NewLanguage(tree_sitter_ocaml.LanguageOCaml())
	ocamlParser = tree_sitter.NewParser()
	ocamlParser.SetLanguage(lang)
}

type ocamlParse struct {
	filepath string
	source   []byte
	tree     *tree_sitter.Tree
}

func newOcamlParse(path string) ocamlParse {
	lspClient.DidOpen(path)
	source := utils.Must1(os.ReadFile(path))
	tree := ocamlParser.Parse(source, nil)
	return ocamlParse{
		filepath: utils.Must1(filepath.Abs(path)),
		source:   source,
		tree:     tree,
	}
}

func main() {
	var rootCmd *cobra.Command
	rootCmd = &cobra.Command{
		Use: "gen",
		Run: func(cmd *cobra.Command, args []string) {
			lspClient = ocaml.NewOCamlClient(filepath.Join(specpath, "interpreter"))
			defer lspClient.Close()

			outFile = utils.Must1(os.Create("generated.go"))
			defer outFile.Close()
			defer outFile.Sync()

			w("// This file is automatically generated. DO NOT EDIT.\n")
			w("package parser\n\n")

			{
				typeParse := newOcamlParse(filepath.Join(specpath, "interpreter", "syntax", "types.ml"))

				root := typeParse.tree.RootNode()
				for _, child := range root.NamedChildren(root.Walk()) {
					if child.GrammarName() == "type_definition" {
						typeParse.parseTypeDef(&child, typeDefs)
					}
				}
			}

			{
				operatorsParse := newOcamlParse(filepath.Join(specpath, "interpreter", "syntax", "operators.ml"))

				root := operatorsParse.tree.RootNode()
				for _, child := range root.NamedChildren(root.Walk()) {
					if child.GrammarName() != "value_definition" {
						continue
					}
					binding := child.NamedChild(0)
					if binding.GrammarName() != "let_binding" {
						continue
					}
					pattern := binding.ChildByFieldName("pattern")

					defType := operatorsParse.getTypeStart(pattern, typeDefs)
					retType := defType
					if defType, ok := defType.(ocaml.Func); ok {
						retType = defType.Out
						for {
							if asFunc, ok := retType.(ocaml.Func); ok {
								retType = asFunc.Out
							} else {
								break
							}
						}
					}

					if asSimple, ok := retType.(ocaml.SimpleType); !ok || asSimple != "instr'" {
						// Not an instruction definition
						continue
					}

					operatorsParse.parseInstrBinding(binding)
				}
			}

			{
				decodeParse := newOcamlParse(filepath.Join(specpath, "interpreter", "binary", "decode.ml"))

				// Find and parse functions in our map
				root := decodeParse.tree.RootNode()
				for _, child := range root.NamedChildren(root.Walk()) {
					if child.GrammarName() != "value_definition" {
						continue
					}
					binding := child.NamedChild(0)
					if binding.GrammarName() != "let_binding" {
						continue
					}
					pattern := binding.ChildByFieldName("pattern")
					if slices.Contains(funcsToTranslate, decodeParse.s(pattern)) {
						decodeParse.parseFunc(&child)
					}
				}
			}
		},
	}

	utils.Must(rootCmd.Execute())
}

func (p *ocamlParse) s(n *tree_sitter.Node) string {
	return n.Utf8Text(p.source)
}

func (p *ocamlParse) parseTypeDef(n *tree_sitter.Node, typeDefs map[string]ocaml.Type) {
	for _, binding := range n.NamedChildren(n.Walk()) {
		if binding.GrammarName() != "type_binding" {
			fmt.Fprintf(os.Stderr, "spurious %s while processing type definitions\n", binding.GrammarName())
			continue
		}

		name := binding.ChildByFieldName("name")
		body := binding.NamedChild(1)

		// fmt.Fprintf(os.Stderr, "parsing type %s: %s\n", p.s(name), body.ToSexp())
		if existingType, ok := typeDefs[p.s(name)]; ok {
			exitWithError("duplicate definition of type %s: already had %s but got %s as well", p.s(name), existingType, p.s(body))
		}

		if body.GrammarName() == "record_declaration" {
			fmt.Fprintf(os.Stderr, "HACK: skipping record_declaration types\n")
			continue
		}

		typeDefs[p.s(name)] = ocaml.Alias{
			Name: p.s(name),
			Type: p.parseTypeDecl(body, typeDefs),
		}
	}
}

func (p *ocamlParse) parseTypeDecl(n *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	switch n.GrammarName() {
	case "type_constructor_path", "constructor_declaration":
		name := p.s(n)
		if existingType, ok := typeDefs[name]; ok {
			return existingType
		}
		return ocaml.SimpleType(name)
	case "constructed_type":
		var cons ocaml.Cons
		tl := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		tr := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		if tlcons, ok := tl.(ocaml.Cons); ok {
			cons = append(cons, tlcons...)
		} else {
			cons = append(cons, tl)
		}
		cons = append(cons, tr)
		return cons
	case "function_type":
		in := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		out := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		return ocaml.Func{
			In:  in,
			Out: out,
		}
	case "variant_declaration":
		variants := make(ocaml.Variants, n.NamedChildCount())
		for i := range n.NamedChildCount() {
			variants[i] = p.parseTypeDecl(n.NamedChild(i), typeDefs)
		}
		return variants
	case "tuple_type":
		var tup ocaml.Tuple
		tl := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		tr := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		if tltup, ok := tl.(ocaml.Tuple); ok {
			tup = append(tup, tltup...)
		} else {
			tup = append(tup, tl)
		}
		tup = append(tup, tr)
		return tup
	default:
		exitWithError("unexpected type declaration node %s", n.GrammarName())
		return nil
	}
}

func (p *ocamlParse) parseInstrBinding(instrDef *tree_sitter.Node) {
	// fmt.Fprintf(os.Stderr, "parsing instr def: %s\n", p.s(instrDef))
	// fmt.Fprintf(os.Stderr, "  %s\n", instrDef.ToSexp())

	pattern := instrDef.ChildByFieldName("pattern")
	var params []*tree_sitter.Node
	for _, child := range instrDef.NamedChildren(instrDef.Walk()) {
		if child.GrammarName() == "parameter" {
			params = append(params, &child)
		}
	}

	structName := fmt.Sprintf("Instr_%s", p.s(pattern))

	w("type %s struct {", structName)
	if len(params) > 0 {
		w("\n")
		for _, param := range params {
			paramType := p.getTypeStart(param, typeDefs)
			w("%s %s\n", paramName(p.s(param)), ocaml2go(paramType))
		}
	}
	w("}\n")

	w("func %s(", funcName("", p.s(pattern), len(params)))
	for _, param := range params {
		paramType := p.getTypeStart(param, typeDefs)
		w("%s %s, ", safeName(p.s(param)), ocaml2go(paramType))
	}
	w(") %s {\n", structName)
	w("return %s{", structName)
	if len(params) > 0 {
		w("\n")
		for _, param := range params {
			w("%s: %s,\n", paramName(p.s(param)), safeName(p.s(param)))
		}
	}
	w("}\n}\n")
}

func (p *ocamlParse) parseFunc(f *tree_sitter.Node) {
	utils.Assert(f.GrammarName() == "value_definition", "expected a let")
	cur := f.Walk()

	binding := Lookup{f}.Child(0, "let_binding").Node
	pattern := Lookup{binding}.Field("pattern", "").Node
	body := Lookup{binding}.Field("body", "").Node
	var params []*tree_sitter.Node
	for _, child := range binding.NamedChildren(cur) {
		if child.GrammarName() == "parameter" {
			params = append(params, &child)
		}
	}

	tmpCount = 0

	name := p.s(pattern)
	funcType := p.getTypeStart(pattern, typeDefs).(ocaml.Func)
	funcResultType := funcType.GetTypeAfterApplyingArgs(len(params))

	w("func %s(", funcName("", name, len(params)))
	for _, param := range params {
		paramName := safeName(p.s(param))
		paramType := p.getTypeEnd(param, typeDefs)
		w("%s %s, ", paramName, ocaml2go(paramType))
	}
	w(") (")
	for i := range funcResultType.Cardinality() {
		w("%s, ", ocaml2go(funcResultType.Get(i)))
	}
	w(") {\n")

	p.parseExpr(body, funcResultType, "", true, true)

	w("}\n\n")
}

var reUnsafeChar = regexp.MustCompile("[^a-zA-Z0-9_]")

func safeName(name string) string {
	return "_" + reUnsafeChar.ReplaceAllString(name, "_")
}

func funcName(mod, name string, numArgs int) string {
	var res string
	if mod != "" {
		res += safeName(mod)
	}
	res += safeName(name)
	if numArgs > 1 {
		res += fmt.Sprintf("_%d", numArgs)
	}
	return res
}

func paramName(name string) string {
	safe := reUnsafeChar.ReplaceAllString(name, "_")
	return strings.ToUpper(safe[:1]) + safe[1:]
}

func (p *ocamlParse) parseExpr(
	expr *tree_sitter.Node,
	expectedType ocaml.Type,
	currentModule string,
	statement bool,
	returnIfTerminal bool,
) []string {
	fmt.Fprintf(os.Stderr, "parsing %s (expecting: %s, in module: %s, as statement: %v, returning if terminal: %v)\n", expr.GrammarName(), expectedType, currentModule, statement, returnIfTerminal)
	fmt.Fprintf(os.Stderr, "  %s\n", p.s(expr))
	fmt.Fprintf(os.Stderr, "  %s\n", expr.ToSexp())

	if returnIfTerminal && !statement {
		exitWithError("for %s expression: cannot return a non-statement", expr.GrammarName())
	}

	switch expr.GrammarName() {
	case "value_path", "constructor_path", "_lowercase_identifier":
		res := tmpVar()
		if statement {
			w("%s := ", res)
		}
		name := safeName(p.s(expr))
		w("%s", name)
		if statement {
			w("\n")
			if returnIfTerminal {
				w("return %s\n", res)
				return nil
			}
			return []string{res}
		}
	case "number":
		n := p.s(expr)
		n = strings.TrimRight(n, "lL")
		w("%s", n)
	case "or_pattern", "tuple_pattern":
		p.parseExpr(expr.NamedChild(0), nil, currentModule, false, false)
		w(", ")
		p.parseExpr(expr.NamedChild(1), nil, currentModule, false, false)
	case "add_operator", "mult_operator", "pow_operator", "rel_operator", "concat_operator":
		// TODO: Implement more of these:
		// https://ocaml.org/manual/5.3/expr.html
		switch p.s(expr) {
		case "=":
			w("==")
		case "<>":
			w("!=")
		case "land":
			w("&")
		default:
			w(" %s ", p.s(expr))
		}
	case "string":
		w("%s", p.s(expr))

	case "application_expression":
		function := expr.ChildByFieldName("function")
		args := expr.ChildrenByFieldName("argument", expr.Walk())

		var funcType ocaml.Func
		if function.GrammarName() == "parenthesized_expression" {
			fmt.Fprintf(os.Stderr, "HACK: A parenthesized expression as a function is spooky, but we can cheat by hovering carefully over the contents.\n")
			funcType = p.getTypeEnd(function.NamedChild(0), typeDefs).(ocaml.Func)
		} else {
			funcType = p.getTypeEnd(function, typeDefs).(ocaml.Func)
		}

		results := resultVars(funcType.Out.Cardinality())
		if statement {
			w("%s := ", strings.Join(results, ", "))
		}

		funcModule := currentModule
		if slices.Contains(funcsToTranslate, p.s(function)) {
			// HACK: Don't apply a module to any function we are translating;
			// they have been defined and are already in scope.
			funcModule = ""
		}

		w("%s(", funcName(funcModule, p.s(function), len(args)))
		for i, arg := range args {
			p.parseExpr(&arg, funcType.GetArgType(i), currentModule, false, false)
			w(", ")
		}
		w(")")

		if statement {
			w("\n")
		}
		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else if statement {
			return results
		} else {
			return nil
		}
	case "field_get_expression":
		w("nil /* TODO: field_get_expression */")
	case "fun_expression":
		body := expr.ChildByFieldName("body")
		var params []*tree_sitter.Node
		for i := range expr.NamedChildCount() {
			child := expr.NamedChild(i)
			if child.Id() == body.Id() {
				break
			}
			params = append(params, child)
		}

		funcType := p.getTypeStart(expr, typeDefs).(ocaml.Func)

		w("func(")
		for _, param := range params {
			paramName := safeName(p.s(param))
			paramType := p.getTypeEnd(param, typeDefs)
			w("%s %s, ", paramName, ocaml2go(paramType))
		}
		w(") (")
		for i := range funcType.Out.Cardinality() {
			w("%s, ", ocaml2go(funcType.Out.Get(i)))
		}
		w(") {\n")

		p.parseExpr(body, funcType.Out, currentModule, true, true)

		w("}")
	case "if_expression":
		condition := expr.ChildByFieldName("condition")

		results := resultVars(expectedType.Cardinality())

		if !statement {
			// Emit an inline, immediately-invoked function
			w("func() (")
			for i := range expectedType.Cardinality() {
				w("%s, ", ocaml2go(expectedType.Get(i)))
			}
			w(") {\n")
		}

		for i := range expectedType.Cardinality() {
			w("var %s %s\n", results[i], ocaml2go(expectedType.Get(i)))
		}
		w("if ")
		p.parseExpr(condition, ocaml.SimpleType("bool"), currentModule, false, false)
		for _, child := range expr.NamedChildren(expr.Walk()) {
			if child.Id() == condition.Id() {
				continue
			}

			switch child.GrammarName() {
			case "then_clause":
				w(" {\n")
				thenRes := p.parseExpr(child.NamedChild(0), expectedType, currentModule, true, false)
				w("%s = %s\n", strings.Join(results, ", "), strings.Join(thenRes, ", "))
				w("} ")
			case "else_clause":
				w(" else {\n")
				elseRes := p.parseExpr(child.NamedChild(0), expectedType, currentModule, true, false)
				w("%s = %s\n", strings.Join(results, ", "), strings.Join(elseRes, ", "))
				w("} ")
			default:
				exitWithError("unknown type in if expression: %s", child.GrammarName())
			}
		}
		w("\n")

		if !statement {
			w("return %s\n", strings.Join(results, ", "))
			w("}()")
			return nil
		} else if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else {
			return results
		}
	case "infix_expression":
		left := expr.ChildByFieldName("left")
		operator := expr.ChildByFieldName("operator")
		right := expr.ChildByFieldName("right")

		results := resultVars(expectedType.Cardinality())
		if statement {
			w("%s := ", strings.Join(results, ", "))
		}

		opType := p.getTypeEnd(operator, typeDefs).(ocaml.Func)
		infixOpGoName, ok := opNames[p.s(operator)]
		if !ok {
			infixOpGoName = p.s(operator)
		}

		funcName := fmt.Sprintf("_operator%s_2", infixOpGoName)
		if opType.GetArgType(0).String()[0] != '\'' {
			funcName = fmt.Sprintf("_%s", opType.GetArgType(0)) + funcName
		}

		w("%s(", funcName)
		p.parseExpr(left, opType.GetArgType(0), currentModule, false, false)
		w(", ")
		p.parseExpr(right, opType.GetArgType(1), currentModule, false, false)
		w(")")

		if statement {
			w("\n")
		}

		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else if statement {
			return results
		} else {
			return nil
		}
	case "let_expression":
		if !statement {
			exitWithError("cannot use let_expression as an expression")
		}

		binding := Lookup{expr}.
			Child(0, "value_definition").
			Child(0, "let_binding").
			Node
		pattern := Lookup{binding}.Field("pattern", "").Node
		body := Lookup{binding}.Field("body", "").Node

		var bindingType ocaml.Type
		if pattern.GrammarName() == "tuple_pattern" {
			var tup ocaml.Tuple
			for _, v := range pattern.NamedChildren(pattern.Walk()) {
				tup = append(tup, p.getTypeEnd(&v, typeDefs))
			}
			bindingType = tup
		} else {
			bindingType = p.getTypeEnd(pattern, typeDefs)
		}
		bindingRes := p.parseExpr(body, bindingType, currentModule, true, false)

		p.parseExpr(pattern, nil, currentModule, false, false)
		w(" := %s\n", strings.Join(bindingRes, ", "))

		return p.parseExpr(expr.NamedChild(1), expectedType, currentModule, true, returnIfTerminal)
	case "list_expression":
		w("nil /* TODO: list_expression */")
	case "local_open_expression":
		// e.g. "Int32.(add lo (shift_left hi 16))"
		mod := p.s(expr.NamedChild(0))
		return p.parseExpr(expr.NamedChild(1), expectedType, mod, statement, returnIfTerminal)
	case "match_expression":
		switchResults := resultVars(expectedType.Cardinality())
		for i := range expectedType.Cardinality() {
			w("var %s %s\n", switchResults[i], ocaml2go(expectedType.Get(i)))
		}

		switchVar := tmpVar()
		w("switch %s := ", switchVar)
		p.parseExpr(expr.NamedChild(0), nil, currentModule, false, false)
		w("; %s {\n", switchVar)

		for _, matchCase := range expr.NamedChildren(expr.Walk())[1:] {
			if matchCase.GrammarName() != "match_case" {
				continue
			}

			pattern := Lookup{&matchCase}.Field("pattern", "").Node
			body := Lookup{&matchCase}.Field("body", "").Node

			switch pattern.GrammarName() {
			case "number":
				w("case ")
				p.parseExpr(pattern, nil, currentModule, false, false)
				w(":\n")
			case "alias_pattern":
				w("case ")
				p.parseExpr(pattern.NamedChild(0), nil, currentModule, false, false)
				w(":\n")

				p.parseExpr(pattern.NamedChild(1), nil, currentModule, false, false)
				w(" := %s\n", switchVar)
			case "_lowercase_identifier":
				w("default:\n")
				w("%s := %s\n", safeName(p.s(pattern)), switchVar)
			default:
				exitWithError("unknown type of match case: %s", pattern.GrammarName())
			}

			res := p.parseExpr(body, expectedType, currentModule, true, false)
			w("%s = %s", strings.Join(switchResults, ", "), strings.Join(res, ", "))

			w("\n")
		}

		w("}\n")

		if returnIfTerminal {
			w("return %s\n", strings.Join(switchResults, ", "))
			return nil
		} else {
			return switchResults
		}
	case "parenthesized_expression":
		return p.parseExpr(expr.NamedChild(0), expectedType, currentModule, statement, returnIfTerminal)
	case "product_expression":
		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		results := resultVars(expectedType.Cardinality())
		if returnIfTerminal {
			w("return ")
		} else if statement {
			w("%s := ", strings.Join(results, ", "))
		}

		var tup ocaml.Tuple
		switch t := expectedType.(type) {
		case ocaml.Tuple:
			tup = t
		case ocaml.Alias:
			tup = t.Type.(ocaml.Tuple)
		default:
			exitWithError("unexpected type in product_expression: %s", expectedType)
		}

		p.parseExpr(left, tup[:len(tup)-1], currentModule, false, false)
		w(", ")
		p.parseExpr(right, tup[len(tup)-1], currentModule, false, false)

		if statement {
			w("\n")
			if returnIfTerminal {
				return nil
			} else {
				return results
			}
		}
	case "record_expression":
		w("nil /* TODO: record_expression */")
	case "sequence_expression":
		if !statement {
			exitWithError("cannot use sequence_expression as an expression")
		}

		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		leftRes := p.parseExpr(left, nil, currentModule, true, false)
		ignores := make([]string, len(leftRes))
		for i := range len(leftRes) {
			ignores[i] = "_"
		}
		w("%s = %s\n", strings.Join(ignores, ", "), strings.Join(leftRes, ", "))

		rightRes := p.parseExpr(right, expectedType, currentModule, true, returnIfTerminal)
		w("\n")

		return rightRes
	case "sign_expression":
		w("%s(", p.s(expr.ChildByFieldName("operator")))
		p.parseExpr(expr.ChildByFieldName("right"), expectedType, currentModule, false, false)
		w(")")
	default:
		fmt.Fprintf(os.Stderr, "%s\n", p.s(expr))
		fmt.Fprintf(os.Stderr, "%s\n", expr.ToSexp())
		exitWithError("unknown expression type %s", expr.GrammarName())
	}

	return nil
}

func w(msg string, args ...any) {
	fmt.Fprintf(outFile, msg, args...)
}

func tmpVar() string {
	tmpCount += 1
	return fmt.Sprintf("__tmp%d", tmpCount)
}

func resultVars(n int) []string {
	if n == 0 {
		return []string{tmpVar()}
	} else {
		vars := make([]string, n)
		for i := range n {
			vars[i] = tmpVar()
		}
		return vars
	}
}

func parseHoverResponse(hover ocaml.M) ocaml.Type {
	value := hover["contents"].(ocaml.M)["value"].(string)
	value = strings.SplitN(value, "***", 2)[0]
	return ocaml.ParseType(value, typeDefs)
}

func (p *ocamlParse) getTypeStart(node *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	hover := utils.Must1(lspClient.Hover(
		p.filepath,
		int(node.StartPosition().Row),
		int(node.StartPosition().Column),
	))
	return parseHoverResponse(hover)
}

func (p *ocamlParse) getTypeEnd(node *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	hover := utils.Must1(lspClient.Hover(
		p.filepath,
		int(node.EndPosition().Row),
		int(node.EndPosition().Column),
	))
	return parseHoverResponse(hover)
}

func exitWithError(msg string, args ...any) {
	msg = fmt.Sprintf(msg, args...)
	panic(fmt.Sprintf("ERROR: %s\n", msg))
}

type Lookup struct {
	Node *tree_sitter.Node
}

func (l Lookup) Child(i uint, grammarName string) Lookup {
	node := l.Node.NamedChild(i)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}

func (l Lookup) Field(fieldName string, grammarName string) Lookup {
	node := l.Node.ChildByFieldName(fieldName)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}
