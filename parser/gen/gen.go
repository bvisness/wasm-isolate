package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/bvisness/wasm-isolate/parser/gen/ocaml"
	"github.com/bvisness/wasm-isolate/utils"
	"github.com/spf13/cobra"
	tree_sitter "github.com/tree-sitter/go-tree-sitter"
	tree_sitter_ocaml "github.com/tree-sitter/tree-sitter-ocaml/bindings/go"
)

var specpath = filepath.Join("gen", "spec")

var funcsToTranslate = []string{
	"memop", "instr",
}

func ocaml2go(t ocaml.Type) string {
	m := map[string]string{
		"int":   "int",
		"int64": "int", // TODO: maybe actually int64?

		"instr list":       "TODO",
		"stream":           "*Stream",
		"local_idx phrase": "*Phrase[int]",
		"instr'":           "Instruction",
		"null":             "Null",

		"'a": "A",
		"'b": "B",
	}
	if goType, ok := m[t.String()]; ok {
		return goType
	} else {
		panic(fmt.Sprintf("no Go type registered for OCaml type %s", t.String()))
	}
}

var actuallyInfix = map[string]string{
	"I32.lt_u":     "<",
	"Int32.logand": "&",
}

var outFile *os.File
var tmpCount int

var lspClient *ocaml.Client
var ocamlParser *tree_sitter.Parser
var typeDefs = make(map[string]ocaml.Type)

func init() {
	lang := tree_sitter.NewLanguage(tree_sitter_ocaml.LanguageOCaml())
	ocamlParser = tree_sitter.NewParser()
	ocamlParser.SetLanguage(lang)
}

type ocamlParse struct {
	filepath string
	source   []byte
	tree     *tree_sitter.Tree
}

func newOcamlParse(path string) ocamlParse {
	lspClient.DidOpen(path)
	source := utils.Must1(os.ReadFile(path))
	tree := ocamlParser.Parse(source, nil)
	return ocamlParse{
		filepath: utils.Must1(filepath.Abs(path)),
		source:   source,
		tree:     tree,
	}
}

func main() {
	var rootCmd *cobra.Command
	rootCmd = &cobra.Command{
		Use: "gen",
		Run: func(cmd *cobra.Command, args []string) {
			lspClient = ocaml.NewOCamlClient(filepath.Join(specpath, "interpreter"))
			defer lspClient.Close()

			{
				typeParse := newOcamlParse(filepath.Join(specpath, "interpreter", "syntax", "types.ml"))

				root := typeParse.tree.RootNode()
				for _, child := range root.NamedChildren(root.Walk()) {
					if child.GrammarName() == "type_definition" {
						typeParse.parseTypeDef(&child, typeDefs)
					}
				}
			}

			{
				decodeParse := newOcamlParse(filepath.Join(specpath, "interpreter", "binary", "decode.ml"))
				outFile = utils.Must1(os.Create("generated.go"))
				defer outFile.Close()
				defer outFile.Sync()

				w("// This file is automatically generated. DO NOT EDIT.\n")
				w("package parser\n\n")

				// Find and parse functions in our map
				root := decodeParse.tree.RootNode()
				for _, child := range root.NamedChildren(root.Walk()) {
					if child.GrammarName() != "value_definition" {
						continue
					}
					binding := child.NamedChild(0)
					if binding.GrammarName() != "let_binding" {
						continue
					}
					pattern := binding.ChildByFieldName("pattern")
					if slices.Contains(funcsToTranslate, decodeParse.s(pattern)) {
						decodeParse.parseFunc(&child)
					}
				}
			}
		},
	}

	utils.Must(rootCmd.Execute())
}

func (p *ocamlParse) s(n *tree_sitter.Node) string {
	return n.Utf8Text(p.source)
}

func (p *ocamlParse) parseTypeDef(n *tree_sitter.Node, typeDefs map[string]ocaml.Type) {
	for _, binding := range n.NamedChildren(n.Walk()) {
		if binding.GrammarName() != "type_binding" {
			fmt.Fprintf(os.Stderr, "spurious %s while processing type definitions\n", binding.GrammarName())
			continue
		}

		name := binding.ChildByFieldName("name")
		body := binding.NamedChild(1)

		// fmt.Fprintf(os.Stderr, "parsing type %s: %s\n", p.s(name), body.ToSexp())
		if existingType, ok := typeDefs[p.s(name)]; ok {
			exitWithError("duplicate definition of type %s: already had %s but got %s as well", p.s(name), existingType, p.s(body))
		}

		if body.GrammarName() == "record_declaration" {
			fmt.Fprintf(os.Stderr, "HACK: skipping record_declaration types\n")
			continue
		}

		typeDefs[p.s(name)] = ocaml.Alias{
			Name: p.s(name),
			Type: p.parseTypeDecl(body, typeDefs),
		}
	}
}

func (p *ocamlParse) parseTypeDecl(n *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	switch n.GrammarName() {
	case "type_constructor_path", "constructor_declaration":
		name := p.s(n)
		if existingType, ok := typeDefs[name]; ok {
			return existingType
		}
		return ocaml.SimpleType(name)
	case "constructed_type":
		var cons ocaml.Cons
		tl := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		tr := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		if tlcons, ok := tl.(ocaml.Cons); ok {
			cons = append(cons, tlcons...)
		} else {
			cons = append(cons, tl)
		}
		cons = append(cons, tr)
		return cons
	case "function_type":
		in := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		out := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		return ocaml.Func{
			In:  in,
			Out: out,
		}
	case "variant_declaration":
		variants := make(ocaml.Variants, n.NamedChildCount())
		for i := range n.NamedChildCount() {
			variants[i] = p.parseTypeDecl(n.NamedChild(i), typeDefs)
		}
		return variants
	case "tuple_type":
		var tup ocaml.Tuple
		tl := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		tr := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		if tltup, ok := tl.(ocaml.Tuple); ok {
			tup = append(tup, tltup...)
		} else {
			tup = append(tup, tl)
		}
		tup = append(tup, tr)
		return tup
	default:
		exitWithError("unexpected type declaration node %s", n.GrammarName())
		return nil
	}
}

func (p *ocamlParse) parseFunc(f *tree_sitter.Node) {
	utils.Assert(f.GrammarName() == "value_definition", "expected a let")
	cur := f.Walk()

	binding := Lookup{f}.Child(0, "let_binding").Node
	pattern := Lookup{binding}.Field("pattern", "").Node
	body := Lookup{binding}.Field("body", "").Node
	var params []*tree_sitter.Node
	for _, child := range binding.NamedChildren(cur) {
		if child.GrammarName() == "parameter" {
			params = append(params, &child)
		}
	}

	tmpCount = 0

	name := p.s(pattern)
	funcType := p.getTypeEnd(pattern, typeDefs).(ocaml.Func)

	w("func %s(", funcName(name, len(params)))
	for _, param := range params {
		paramName := safeName(p.s(param))
		paramType := p.getTypeEnd(param, typeDefs)
		w("%s %s, ", paramName, ocaml2go(paramType))
	}
	w(") (")
	for i := range funcType.Out.Cardinality() {
		w("%s, ", ocaml2go(funcType.Out.Get(i)))
	}
	w(") {\n")

	p.parseExpr(body, funcType.Out, true, true)

	w("}\n\n")
}

var reUnsafeChar = regexp.MustCompile("[^a-zA-Z0-9_]")

func safeName(name string) string {
	return "_" + reUnsafeChar.ReplaceAllString(name, "_")
}

func funcName(name string, numArgs int) string {
	name = safeName(name)
	if numArgs > 1 {
		name += fmt.Sprintf("_%d", numArgs)
	}
	return name
}

func (p *ocamlParse) parseExpr(expr *tree_sitter.Node, expectedType ocaml.Type, statement bool, returnIfTerminal bool) []string {
	fmt.Fprintf(os.Stderr, "parsing %s (expecting: %s, as statement: %v, returning if terminal: %v)\n", expr.GrammarName(), expectedType, statement, returnIfTerminal)
	fmt.Fprintf(os.Stderr, "  %s\n", p.s(expr))
	fmt.Fprintf(os.Stderr, "  %s\n", expr.ToSexp())

	if returnIfTerminal && !statement {
		exitWithError("for %s expression: cannot return a non-statement", expr.GrammarName())
	}

	switch expr.GrammarName() {
	case "value_path", "constructor_path", "_lowercase_identifier":
		res := tmpVar()
		if statement {
			w("%s := ", res)
		}
		name := safeName(p.s(expr))
		w("%s", name)
		if statement {
			w("\n")
			if returnIfTerminal {
				w("return %s\n", res)
				return nil
			}
			return []string{res}
		}
	case "number":
		n := p.s(expr)
		n = strings.TrimRight(n, "lL")
		w("%s", n)
	case "or_pattern", "tuple_pattern":
		p.parseExpr(expr.NamedChild(0), nil, false, false)
		w(", ")
		p.parseExpr(expr.NamedChild(1), nil, false, false)
	case "add_operator", "mult_operator", "rel_operator", "concat_operator":
		// TODO: Implement more of these:
		// https://ocaml.org/manual/5.3/expr.html
		switch p.s(expr) {
		case "=":
			w("==")
		case "<>":
			w("!=")
		case "land":
			w("&")
		default:
			w(" %s ", p.s(expr))
		}
	case "string":
		w("%s", p.s(expr))

	case "application_expression":
		function := expr.ChildByFieldName("function")
		args := expr.ChildrenByFieldName("argument", expr.Walk())

		var funcType ocaml.Func
		if function.GrammarName() == "parenthesized_expression" {
			fmt.Fprintf(os.Stderr, "HACK: A parenthesized expression as a function is spooky, but we can cheat by hovering carefully over the contents.\n")
			funcType = p.getTypeEnd(function.NamedChild(0), typeDefs).(ocaml.Func)
		} else {
			funcType = p.getTypeEnd(function, typeDefs).(ocaml.Func)
		}

		results := resultVars(funcType.Out.Cardinality())
		if statement {
			w("%s := ", strings.Join(results, ", "))
		}

		if infixOp, ok := actuallyInfix[p.s(function)]; ok {
			w("(")
			p.parseExpr(&args[0], nil, false, false)
			w(")%s(", infixOp)
			p.parseExpr(&args[1], nil, false, false)
			w(")")
		} else {
			w("%s(", funcName(p.s(function), len(args)))
			for i, arg := range args {
				p.parseExpr(&arg, funcType.GetArgType(i), false, false)
				w(", ")
			}
			w(")")
		}

		if statement {
			w("\n")
		}
		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else if statement {
			return results
		} else {
			return nil
		}
	case "fun_expression":
		body := expr.ChildByFieldName("body")
		var params []*tree_sitter.Node
		for i := range expr.NamedChildCount() {
			child := expr.NamedChild(i)
			if child.Id() == body.Id() {
				break
			}
			params = append(params, child)
		}

		funcType := p.getTypeStart(expr, typeDefs).(ocaml.Func)

		w("func(")
		for _, param := range params {
			paramName := safeName(p.s(param))
			paramType := p.getTypeEnd(param, typeDefs)
			w("%s %s, ", paramName, ocaml2go(paramType))
		}
		w(") (")
		for i := range funcType.Out.Cardinality() {
			w("%s, ", ocaml2go(funcType.Out.Get(i)))
		}
		w(") {\n")

		p.parseExpr(body, funcType.Out, true, true)

		w("}")
	case "if_expression":
		condition := expr.ChildByFieldName("condition")

		results := resultVars(expectedType.Cardinality())

		if !statement {
			// Emit an inline, immediately-invoked function
			w("func() (")
			for i := range expectedType.Cardinality() {
				w("%s, ", ocaml2go(expectedType.Get(i)))
			}
			w(") {\n")
		}

		for i := range expectedType.Cardinality() {
			w("var %s %s\n", results[i], ocaml2go(expectedType.Get(i)))
		}
		w("if ")
		p.parseExpr(condition, ocaml.SimpleType("bool"), false, false)
		for _, child := range expr.NamedChildren(expr.Walk()) {
			if child.Id() == condition.Id() {
				continue
			}

			switch child.GrammarName() {
			case "then_clause":
				w(" {\n")
				thenRes := p.parseExpr(child.NamedChild(0), expectedType, true, false)
				w("%s = %s\n", strings.Join(results, ", "), strings.Join(thenRes, ", "))
				w("} ")
			case "else_clause":
				w(" else {\n")
				elseRes := p.parseExpr(child.NamedChild(0), expectedType, true, false)
				w("%s = %s\n", strings.Join(results, ", "), strings.Join(elseRes, ", "))
				w("} ")
			default:
				exitWithError("unknown type in if expression: %s", child.GrammarName())
			}
		}
		w("\n")

		if !statement {
			w("return %s\n", strings.Join(results, ", "))
			w("}()")
			return nil
		} else if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else {
			return results
		}
	case "infix_expression":
		left := expr.ChildByFieldName("left")
		operator := expr.ChildByFieldName("operator")
		right := expr.ChildByFieldName("right")

		results := resultVars(expectedType.Cardinality())
		if statement {
			w("%s := ", strings.Join(results, ", "))
		}

		if p.s(operator) == "@@" {
			// Super jank operator overload:
			// val (@@) : 'a -> region -> 'a phrase
			w("_operatorAtAt_2(")
			p.parseExpr(left, nil, false, false)
			w(", ")
			p.parseExpr(right, nil, false, false)
			w(")")
		} else {
			opType := p.getTypeEnd(operator, typeDefs).(ocaml.Func)
			p.parseExpr(left, opType.GetArgType(0), false, false)
			p.parseExpr(operator, nil, false, false)
			p.parseExpr(right, opType.GetArgType(1), false, false)
		}

		if statement {
			w("\n")
		}

		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else if statement {
			return results
		} else {
			return nil
		}
	case "let_expression":
		if !statement {
			exitWithError("cannot use let_expression as an expression")
		}

		binding := Lookup{expr}.
			Child(0, "value_definition").
			Child(0, "let_binding").
			Node
		pattern := Lookup{binding}.Field("pattern", "").Node
		body := Lookup{binding}.Field("body", "").Node

		var bindingType ocaml.Type
		if pattern.GrammarName() == "tuple_pattern" {
			var tup ocaml.Tuple
			for _, v := range pattern.NamedChildren(pattern.Walk()) {
				tup = append(tup, p.getTypeEnd(&v, typeDefs))
			}
			bindingType = tup
		} else {
			bindingType = p.getTypeEnd(pattern, typeDefs)
		}
		bindingRes := p.parseExpr(body, bindingType, true, false)

		p.parseExpr(pattern, nil, false, false)
		w(" := %s\n", strings.Join(bindingRes, ", "))

		return p.parseExpr(expr.NamedChild(1), expectedType, true, returnIfTerminal)
	case "list_expression":
		w("nil /* TODO: list_expression */")
	case "local_open_expression":
		// e.g. "Source.(0l @@ no_region)"
		return p.parseExpr(expr.NamedChild(1), expectedType, statement, returnIfTerminal)
	case "match_expression":
		switchResults := resultVars(expectedType.Cardinality())
		for i := range expectedType.Cardinality() {
			w("var %s %s\n", switchResults[i], ocaml2go(expectedType.Get(i)))
		}

		switchVar := tmpVar()
		w("switch %s := ", switchVar)
		p.parseExpr(expr.NamedChild(0), nil, false, false)
		w("; %s {\n", switchVar)

		for _, matchCase := range expr.NamedChildren(expr.Walk())[1:] {
			if matchCase.GrammarName() != "match_case" {
				continue
			}

			pattern := Lookup{&matchCase}.Field("pattern", "").Node
			body := Lookup{&matchCase}.Field("body", "").Node

			switch pattern.GrammarName() {
			case "number":
				w("case ")
				p.parseExpr(pattern, nil, false, false)
				w(":\n")
			case "alias_pattern":
				w("case ")
				p.parseExpr(pattern.NamedChild(0), nil, false, false)
				w(":\n")

				p.parseExpr(pattern.NamedChild(1), nil, false, false)
				w(" := %s\n", switchVar)
			case "_lowercase_identifier":
				w("default:\n")
				w("%s := %s\n", p.s(pattern), switchVar)
			default:
				exitWithError("unknown type of match case: %s", pattern.GrammarName())
			}

			res := p.parseExpr(body, expectedType, true, false)
			w("%s = %s", strings.Join(switchResults, ", "), strings.Join(res, ", "))

			w("\n")
		}

		w("}\n")

		if returnIfTerminal {
			w("return %s\n", strings.Join(switchResults, ", "))
			return nil
		} else {
			return switchResults
		}
	case "parenthesized_expression":
		return p.parseExpr(expr.NamedChild(0), expectedType, statement, returnIfTerminal)
	case "product_expression":
		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		results := resultVars(expectedType.Cardinality())
		if returnIfTerminal {
			w("return ")
		} else if statement {
			w("%s := ", strings.Join(results, ", "))
		}

		var tup ocaml.Tuple
		switch t := expectedType.(type) {
		case ocaml.Tuple:
			tup = t
		case ocaml.Alias:
			tup = t.Type.(ocaml.Tuple)
		default:
			exitWithError("unexpected type in product_expression: %s", expectedType)
		}

		p.parseExpr(left, tup[:len(tup)-1], false, false)
		w(", ")
		p.parseExpr(right, tup[len(tup)-1], false, false)

		if statement {
			w("\n")
			if returnIfTerminal {
				return nil
			} else {
				return results
			}
		}
	case "sequence_expression":
		if !statement {
			exitWithError("cannot use sequence_expression as an expression")
		}

		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		leftRes := p.parseExpr(left, nil, true, false)
		ignores := make([]string, len(leftRes))
		for i := range len(leftRes) {
			ignores[i] = "_"
		}
		w("%s = %s\n", strings.Join(ignores, ", "), strings.Join(leftRes, ", "))

		rightRes := p.parseExpr(right, expectedType, true, returnIfTerminal)
		w("\n")

		return rightRes
	default:
		fmt.Fprintf(os.Stderr, "%s\n", p.s(expr))
		fmt.Fprintf(os.Stderr, "%s\n", expr.ToSexp())
		exitWithError("unknown expression type %s", expr.GrammarName())
	}

	return nil
}

func w(msg string, args ...any) {
	fmt.Fprintf(outFile, msg, args...)
}

func tmpVar() string {
	tmpCount += 1
	return fmt.Sprintf("__tmp%d", tmpCount)
}

func resultVars(n int) []string {
	if n == 0 {
		return []string{tmpVar()}
	} else {
		vars := make([]string, n)
		for i := range n {
			vars[i] = tmpVar()
		}
		return vars
	}
}

func parseHoverResponse(hover ocaml.M) ocaml.Type {
	value := hover["contents"].(ocaml.M)["value"].(string)
	value = strings.SplitN(value, "***", 2)[0]
	return ocaml.ParseType(value, typeDefs)
}

func (p *ocamlParse) getTypeStart(node *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	hover := utils.Must1(lspClient.Hover(
		p.filepath,
		int(node.StartPosition().Row),
		int(node.StartPosition().Column),
	))
	return parseHoverResponse(hover)
}

func (p *ocamlParse) getTypeEnd(node *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	hover := utils.Must1(lspClient.Hover(
		p.filepath,
		int(node.EndPosition().Row),
		int(node.EndPosition().Column),
	))
	return parseHoverResponse(hover)
}

func exitWithError(msg string, args ...any) {
	msg = fmt.Sprintf(msg, args...)
	panic(fmt.Sprintf("ERROR: %s\n", msg))
}

type Lookup struct {
	Node *tree_sitter.Node
}

func (l Lookup) Child(i uint, grammarName string) Lookup {
	node := l.Node.NamedChild(i)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}

func (l Lookup) Field(fieldName string, grammarName string) Lookup {
	node := l.Node.ChildByFieldName(fieldName)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}
