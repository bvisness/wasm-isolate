package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/bvisness/wasm-isolate/parser/gen/ocaml"
	"github.com/bvisness/wasm-isolate/utils"
	"github.com/spf13/cobra"
	tree_sitter "github.com/tree-sitter/go-tree-sitter"
	tree_sitter_ocaml "github.com/tree-sitter/tree-sitter-ocaml/bindings/go"
)

var specpath = filepath.Join("gen", "spec")

var funcsToTranslate = []string{
	// Generic values
	"bit", "byte", "word16", "word32", "word64",
	"uN", "sN", "u32", "u64", "s7", "s32", "s33", "s64", "f32", "f64", "v128",
	"len32", "string",

	// Types
	"zero", "var",
	"mutability", "var_type", "num_type", "vec_type", "heap_type", "ref_type",
	"val_type", "result_type", "pack_type", "storage_type", "field_type",
	"struct_type", "array_type", "func_type", "str_type", "sub_type", "rec_type",
	"limits", "table_type", "global_type", "tag_type",

	// Instructions
	"op", "end_", "memop",
	"block_type", "local",
	"instr",
}

func ocaml2go(t ocaml.Type) string {
	m := map[string]string{
		"bool":   "bool",
		"string": "string",

		"int":    "OInt",
		"int32":  "OInt32",
		"int64":  "OInt64",
		"F32.t":  "float32",
		"F64.t":  "float64",
		"V128.t": "V128",

		"address":   "OInt64",
		"type_idx":  "OInt32",
		"local_idx": "OInt32",

		"block_type": "BlockType",
		"heap_type":  "HeapType",
		"ref_type":   "RefType",
		"null":       "Null",

		"idx":    "*Phrase[OInt32]",
		"instr'": "Instruction_",
		"instr":  "*Phrase[Instruction_]",
		"local'": "Local_",
		"local":  "*Phrase[Local_]",

		"stream": "*Stream",
	}

	if goType, ok := m[t.String()]; ok {
		return goType
	} else if asCons, ok := t.(ocaml.Cons); ok {
		last := asCons[len(asCons)-1]
		switch last {
		case ocaml.SimpleType("list"):
			return fmt.Sprintf("[]%s", ocaml2go(asCons[:len(asCons)-1]))
		case ocaml.SimpleType("phrase"):
			return fmt.Sprintf("*Phrase[%s]", ocaml2go(asCons[:len(asCons)-1]))
		case ocaml.SimpleType("option"):
			return fmt.Sprintf("*%s", ocaml2go(asCons[:len(asCons)-1]))
		}
	} else if asFunc, ok := t.(ocaml.Func); ok {
		return fmt.Sprintf("func(%s) %s", ocaml2go(asFunc.In), ocaml2go(asFunc.Out))
	}

	return fmt.Sprintf("TODO /* %s */", t)
}

var opNames = map[string]string{
	"@@": "AtAt",
	"+":  "Plus",
	"-":  "Minus",
	"=":  "Eq",
	"<>": "NotEq",
	">":  "Gt",
	"<":  "Lt",
	">=": "Gte",
	"<=": "Lte",
	"||": "Or",
}

var outFile *os.File
var tmpCount int

var lspClient *ocaml.Client
var ocamlParser *tree_sitter.Parser
var typeDefs = make(map[string]ocaml.Type)

func init() {
	lang := tree_sitter.NewLanguage(tree_sitter_ocaml.LanguageOCaml())
	ocamlParser = tree_sitter.NewParser()
	ocamlParser.SetLanguage(lang)
}

type ocamlParse struct {
	filepath string
	source   []byte
	tree     *tree_sitter.Tree
}

func newOcamlParse(path string) ocamlParse {
	lspClient.DidOpen(path)
	source := utils.Must1(os.ReadFile(path))
	tree := ocamlParser.Parse(source, nil)
	return ocamlParse{
		filepath: utils.Must1(filepath.Abs(path)),
		source:   source,
		tree:     tree,
	}
}

func main() {
	var rootCmd *cobra.Command
	rootCmd = &cobra.Command{
		Use: "gen",
		Run: func(cmd *cobra.Command, args []string) {
			lspClient = ocaml.NewOCamlClient(filepath.Join(specpath, "interpreter"))
			defer lspClient.Close()

			outFile = utils.Must1(os.Create("generated.go"))
			defer outFile.Close()
			defer outFile.Sync()

			w("// This file is automatically generated. DO NOT EDIT.\n")
			w("package parser\n\n")

			{
				typeParse := newOcamlParse(filepath.Join(specpath, "interpreter", "syntax", "types.ml"))

				root := typeParse.tree.RootNode()
				for _, child := range root.NamedChildren(root.Walk()) {
					if child.GrammarName() == "type_definition" {
						typeParse.parseTypeDef(&child, typeDefs)
					}
				}
			}

			if false {
				operatorsParse := newOcamlParse(filepath.Join(specpath, "interpreter", "syntax", "operators.ml"))

				root := operatorsParse.tree.RootNode()
				for _, child := range root.NamedChildren(root.Walk()) {
					if child.GrammarName() != "value_definition" {
						continue
					}
					binding := child.NamedChild(0)
					if binding.GrammarName() != "let_binding" {
						continue
					}
					pattern := binding.ChildByFieldName("pattern")

					defType := operatorsParse.getTypeStart(pattern, typeDefs)
					retType := defType
					if defType, ok := defType.(ocaml.Func); ok {
						retType = defType.Out
						for {
							if asFunc, ok := retType.(ocaml.Func); ok {
								retType = asFunc.Out
							} else {
								break
							}
						}
					}

					if asSimple, ok := retType.(ocaml.SimpleType); !ok || asSimple != "instr'" {
						// Not an instruction definition
						continue
					}

					operatorsParse.parseInstrBinding(binding)
				}
			}

			{
				decodeParse := newOcamlParse(filepath.Join(specpath, "interpreter", "binary", "decode.ml"))

				// Find and parse functions in our map
				root := decodeParse.tree.RootNode()
				for _, def := range root.NamedChildren(root.Walk()) {
					if def.GrammarName() != "value_definition" {
						continue
					}

					for _, binding := range def.NamedChildren(def.Walk()) {
						if binding.GrammarName() != "let_binding" {
							continue
						}
						pattern := binding.ChildByFieldName("pattern")
						if slices.Contains(funcsToTranslate, decodeParse.s(pattern)) {
							decodeParse.parseFunc(&binding)
						}
					}
				}
			}
		},
	}

	utils.Must(rootCmd.Execute())
}

func (p *ocamlParse) s(n *tree_sitter.Node) string {
	return n.Utf8Text(p.source)
}

func (p *ocamlParse) parseTypeDef(n *tree_sitter.Node, typeDefs map[string]ocaml.Type) {
	for _, binding := range n.NamedChildren(n.Walk()) {
		if binding.GrammarName() != "type_binding" {
			fmt.Fprintf(os.Stderr, "spurious %s while processing type definitions\n", binding.GrammarName())
			continue
		}

		name := binding.ChildByFieldName("name")
		body := binding.NamedChild(1)

		// fmt.Fprintf(os.Stderr, "parsing type %s: %s\n", p.s(name), body.ToSexp())
		if existingType, ok := typeDefs[p.s(name)]; ok {
			exitWithError("duplicate definition of type %s: already had %s but got %s as well", p.s(name), existingType, p.s(body))
		}

		if body.GrammarName() == "record_declaration" {
			fmt.Fprintf(os.Stderr, "HACK: skipping record_declaration types\n")
			continue
		}

		typeDefs[p.s(name)] = ocaml.Alias{
			Name: p.s(name),
			Type: p.parseTypeDecl(body, typeDefs),
		}
	}
}

func (p *ocamlParse) parseTypeDecl(n *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	switch n.GrammarName() {
	case "type_constructor_path", "constructor_declaration":
		name := p.s(n)
		if existingType, ok := typeDefs[name]; ok {
			return existingType
		}
		return ocaml.SimpleType(name)
	case "constructed_type":
		var cons ocaml.Cons
		tl := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		tr := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		if tlcons, ok := tl.(ocaml.Cons); ok {
			cons = append(cons, tlcons...)
		} else {
			cons = append(cons, tl)
		}
		cons = append(cons, tr)
		return cons
	case "function_type":
		in := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		out := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		return ocaml.Func{
			In:  in,
			Out: out,
		}
	case "variant_declaration":
		variants := make(ocaml.Variants, n.NamedChildCount())
		for i := range n.NamedChildCount() {
			variants[i] = p.parseTypeDecl(n.NamedChild(i), typeDefs)
		}
		return variants
	case "tuple_type":
		var tup ocaml.Tuple
		tl := p.parseTypeDecl(n.NamedChild(0), typeDefs)
		tr := p.parseTypeDecl(n.NamedChild(1), typeDefs)
		if tltup, ok := tl.(ocaml.Tuple); ok {
			tup = append(tup, tltup...)
		} else {
			tup = append(tup, tl)
		}
		tup = append(tup, tr)
		return tup
	default:
		exitWithError("unexpected type declaration node %s", n.GrammarName())
		return nil
	}
}

func (p *ocamlParse) parseInstrBinding(instrDef *tree_sitter.Node) {
	// fmt.Fprintf(os.Stderr, "parsing instr def: %s\n", p.s(instrDef))
	// fmt.Fprintf(os.Stderr, "  %s\n", instrDef.ToSexp())

	pattern := instrDef.ChildByFieldName("pattern")
	var params []*tree_sitter.Node
	for _, child := range instrDef.NamedChildren(instrDef.Walk()) {
		if child.GrammarName() == "parameter" {
			params = append(params, &child)
		}
	}

	structName := fmt.Sprintf("Instr_%s", p.s(pattern))

	w("type %s struct {", structName)
	if len(params) > 0 {
		w("\n")
		for _, param := range params {
			paramType := p.getTypeStart(param, typeDefs)
			w("%s %s\n", paramName(p.s(param)), ocaml2go(paramType))
		}
	}
	w("}\n")

	constructorName := funcName("", p.s(pattern), len(params))
	w("func %s(", constructorName)
	for _, param := range params {
		paramType := p.getTypeStart(param, typeDefs)
		w("%s %s, ", safeName(p.s(param)), ocaml2go(paramType))
	}
	w(") %s {\n", structName)
	w("return %s{", structName)
	if len(params) > 0 {
		w("\n")
		for _, param := range params {
			w("%s: %s,\n", paramName(p.s(param)), safeName(p.s(param)))
		}
	}
	w("}\n}\n")

	w("var %s = %s\n\n", funcName("", p.s(pattern), -1), constructorName)
}

func (p *ocamlParse) parseFunc(f *tree_sitter.Node) {
	utils.Assert(f.GrammarName() == "let_binding", "expected a let")
	cur := f.Walk()

	pattern := Lookup{f}.Field("pattern", "").Node
	body := Lookup{f}.Field("body", "").Node
	var params []*tree_sitter.Node
	for _, child := range f.NamedChildren(cur) {
		if child.GrammarName() == "parameter" {
			params = append(params, &child)
		}
	}

	tmpCount = 0

	name := p.s(pattern)
	funcType := p.getTypeStart(pattern, typeDefs).(ocaml.Func)
	funcResultType := funcType.GetTypeAfterApplyingArgs(len(params))

	fullFuncName := funcName("", name, len(params))
	w("func %s(", fullFuncName)
	for _, param := range params {
		paramName := safeName(p.s(param))
		paramType := p.getTypeEnd(param, typeDefs)
		w("%s %s, ", paramName, ocaml2go(paramType))
	}
	w(") (")
	for i := range funcResultType.Cardinality() {
		w("%s, ", ocaml2go(funcResultType.Get(i)))
	}
	w(") {\n")

	p.parseExpr(body, funcResultType, "", true, true)

	w("}\n\n")

	w("var %s = %s\n\n", funcName("", p.s(pattern), -1), fullFuncName)
}

var reUnsafeChar = regexp.MustCompile("[^a-zA-Z0-9_]")

func safeName(name string) string {
	return "_" + reUnsafeChar.ReplaceAllString(name, "_")
}

func funcName(mod, name string, numArgs int) string {
	var res string
	if mod != "" {
		res += safeName(mod)
	}
	res += safeName(name)
	if numArgs >= 0 {
		res += fmt.Sprintf("_%d", numArgs)
	}
	return res
}

func paramName(name string) string {
	safe := reUnsafeChar.ReplaceAllString(name, "_")
	return strings.ToUpper(safe[:1]) + safe[1:]
}

func (p *ocamlParse) parseExpr(
	expr *tree_sitter.Node,
	expectedType ocaml.Type,
	currentModule string,
	statement bool,
	returnIfTerminal bool,
) []string {
	fmt.Fprintf(os.Stderr, "parsing %s (expecting: %s, in module: %s, as statement: %v, returning if terminal: %v)\n", expr.GrammarName(), expectedType, currentModule, statement, returnIfTerminal)
	fmt.Fprintf(os.Stderr, "  %s\n", p.s(expr))
	fmt.Fprintf(os.Stderr, "  %s\n", expr.ToSexp())

	if returnIfTerminal && !statement {
		exitWithError("for %s expression: cannot return a non-statement", expr.GrammarName())
	}

	switch expr.GrammarName() {
	case "value_path", "constructor_path", "_lowercase_identifier":
		res := tmpVar()
		if statement {
			w("%s := ", res)
		}
		name := safeName(p.s(expr))
		w("%s", name)
		if statement {
			w("\n")
			if returnIfTerminal {
				w("return %s\n", res)
				return nil
			}
			return []string{res}
		}
	case "number", "signed_number":
		n := p.s(expr)
		n = strings.TrimRight(n, "lL")
		w("%s", n)
	case "or_pattern", "tuple_pattern":
		p.parseExpr(expr.NamedChild(0), nil, currentModule, false, false)
		w(", ")
		p.parseExpr(expr.NamedChild(1), nil, currentModule, false, false)
	case "add_operator", "mult_operator", "pow_operator", "rel_operator", "concat_operator":
		// TODO: Implement more of these:
		// https://ocaml.org/manual/5.3/expr.html
		switch p.s(expr) {
		case "=":
			w("==")
		case "<>":
			w("!=")
		case "land":
			w("&")
		default:
			w(" %s ", p.s(expr))
		}
	case "string":
		w("%s", p.s(expr))

	case "application_expression":
		function := expr.ChildByFieldName("function")
		args := expr.ChildrenByFieldName("argument", expr.Walk())

		var funcType ocaml.Func
		if function.GrammarName() == "parenthesized_expression" {
			fmt.Fprintf(os.Stderr, "HACK: A parenthesized expression as a function is spooky, but we can cheat by hovering carefully over the contents.\n")
			funcType = p.getTypeEnd(function.NamedChild(0), typeDefs).(ocaml.Func)
		} else {
			funcType = p.getTypeEnd(function, typeDefs).(ocaml.Func)
		}

		results := resultVars(funcType.GetTypeAfterApplyingArgs(len(args)).Cardinality())
		if len(results) > 0 && statement {
			w("%s := ", strings.Join(results, ", "))
		}

		funcModule := currentModule
		if slices.Contains(funcsToTranslate, p.s(function)) {
			// HACK: Don't apply a module to any function we are translating;
			// they have been defined and are already in scope.
			funcModule = ""
		}

		w("%s(", funcName(funcModule, p.s(function), len(args)))
		for i, arg := range args {
			p.parseExpr(&arg, funcType.GetArgType(i), currentModule, false, false)
			w(", ")
		}
		w(")")

		if statement {
			w("\n")
		}
		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else if statement {
			return results
		} else {
			return nil
		}
	case "field_get_expression":
		w("nil /* TODO: field_get_expression */")
	case "fun_expression":
		body := expr.ChildByFieldName("body")
		var params []*tree_sitter.Node
		for i := range expr.NamedChildCount() {
			child := expr.NamedChild(i)
			if child.Id() == body.Id() {
				break
			}
			params = append(params, child)
		}

		funcType := p.getTypeStart(expr, typeDefs).(ocaml.Func)

		w("func(")
		for _, param := range params {
			paramName := safeName(p.s(param))
			paramType := p.getTypeEnd(param, typeDefs)
			w("%s %s, ", paramName, ocaml2go(paramType))
		}
		w(") (")
		for i := range funcType.Out.Cardinality() {
			w("%s, ", ocaml2go(funcType.Out.Get(i)))
		}
		w(") {\n")

		p.parseExpr(body, funcType.Out, currentModule, true, true)

		w("}")
	case "if_expression":
		condition := expr.ChildByFieldName("condition")

		results := resultVars(expectedType.Cardinality())

		if !statement {
			// Emit an inline, immediately-invoked function
			w("func() (")
			for i := range expectedType.Cardinality() {
				w("%s, ", ocaml2go(expectedType.Get(i)))
			}
			w(") {\n")
		}

		for i := range expectedType.Cardinality() {
			w("var %s %s\n", results[i], ocaml2go(expectedType.Get(i)))
		}
		w("if ")
		p.parseExpr(condition, ocaml.SimpleType("bool"), currentModule, false, false)
		for _, child := range expr.NamedChildren(expr.Walk()) {
			if child.Id() == condition.Id() {
				continue
			}

			switch child.GrammarName() {
			case "then_clause":
				w(" {\n")
				thenRes := p.parseExpr(child.NamedChild(0), expectedType, currentModule, true, false)
				if len(results) > 0 {
					w("%s = %s\n", strings.Join(results, ", "), strings.Join(thenRes, ", "))
				}
				w("} ")
			case "else_clause":
				w(" else {\n")
				elseRes := p.parseExpr(child.NamedChild(0), expectedType, currentModule, true, false)
				if len(results) > 0 {
					w("%s = %s\n", strings.Join(results, ", "), strings.Join(elseRes, ", "))
				}
				w("} ")
			default:
				exitWithError("unknown type in if expression: %s", child.GrammarName())
			}
		}
		w("\n")

		if !statement {
			w("return %s\n", strings.Join(results, ", "))
			w("}()")
			return nil
		} else if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else {
			return results
		}
	case "infix_expression":
		left := expr.ChildByFieldName("left")
		operator := expr.ChildByFieldName("operator")
		right := expr.ChildByFieldName("right")

		results := resultVars(expectedType.Cardinality())
		if len(results) > 0 && statement {
			w("%s := ", strings.Join(results, ", "))
		}

		opType := p.getTypeEnd(operator, typeDefs).(ocaml.Func)
		infixOpGoName, ok := opNames[p.s(operator)]
		if !ok {
			infixOpGoName = p.s(operator)
		}

		funcName := fmt.Sprintf("_operator%s_2", infixOpGoName)
		if opType.GetArgType(0).String()[0] != '\'' {
			funcName = fmt.Sprintf("_%s", opType.GetArgType(0)) + funcName
		}

		w("%s(", funcName)
		p.parseExpr(left, opType.GetArgType(0), currentModule, false, false)
		w(", ")
		p.parseExpr(right, opType.GetArgType(1), currentModule, false, false)
		w(")")

		if statement {
			w("\n")
		}

		if returnIfTerminal {
			w("return %s\n", strings.Join(results, ", "))
			return nil
		} else if statement {
			return results
		} else {
			return nil
		}
	case "let_expression":
		if !statement {
			exitWithError("cannot use let_expression as an expression")
		}

		binding := Lookup{expr}.
			Child(0, "value_definition").
			Child(0, "let_binding").
			Node
		pattern := Lookup{binding}.Field("pattern", "").Node
		body := Lookup{binding}.Field("body", "").Node

		var bindingType ocaml.Type
		if pattern.GrammarName() == "tuple_pattern" {
			var tup ocaml.Tuple
			for _, v := range pattern.NamedChildren(pattern.Walk()) {
				tup = append(tup, p.getTypeEnd(&v, typeDefs))
			}
			bindingType = tup
		} else {
			bindingType = p.getTypeEnd(pattern, typeDefs)
		}
		bindingRes := p.parseExpr(body, bindingType, currentModule, true, false)

		p.parseExpr(pattern, nil, currentModule, false, false)
		w(" := %s\n", strings.Join(bindingRes, ", "))

		return p.parseExpr(expr.NamedChild(1), expectedType, currentModule, true, returnIfTerminal)
	case "list_expression":
		listType := p.getTypeEnd(expr, typeDefs)
		var elemType ocaml.Type

		if asCons, ok := listType.(ocaml.Cons); ok {
			if len(asCons) != 2 || asCons[1] != ocaml.SimpleType("list") {
				exitWithError("list_expression needs a list type, but got: %s", expectedType)
			}
			elemType = asCons[0]
		} else {
			exitWithError("list_expression needs a cons type (that is a list), but got: %s", expectedType)
		}

		// TODO: Statement mode

		w("[]%s{", ocaml2go(elemType))
		for _, child := range expr.NamedChildren(expr.Walk()) {
			p.parseExpr(&child, elemType, currentModule, false, false)
			w(", ")
		}
		w("}")
	case "local_open_expression":
		// e.g. "Int32.(add lo (shift_left hi 16))"
		mod := p.s(expr.NamedChild(0))
		return p.parseExpr(expr.NamedChild(1), expectedType, mod, statement, returnIfTerminal)
	case "match_expression":
		matchResults := resultVars(expectedType.Cardinality())
		for i := range expectedType.Cardinality() {
			w("var %s %s\n", matchResults[i], ocaml2go(expectedType.Get(i)))
		}

		matchVar := tmpVar()
		w("%s := ", matchVar)
		p.parseExpr(expr.NamedChild(0), nil, currentModule, false, false)
		w("\n")

		for i, matchCase := range expr.NamedChildren(expr.Walk())[1:] {
			if matchCase.GrammarName() != "match_case" {
				continue
			}

			pattern := Lookup{&matchCase}.Field("pattern", "").Node
			body := Lookup{&matchCase}.Field("body", "").Node
			var guard *tree_sitter.Node
			for _, child := range matchCase.NamedChildren(matchCase.Walk()) {
				if child.GrammarName() == "guard" {
					guard = child.NamedChild(0)
				}
			}

			if i == 0 {
				w("if ")
			} else {
				w("} else if ")
			}

			// Will open the body of the if
			p.parseMatchPattern(pattern, matchVar, guard)

			res := p.parseExpr(body, expectedType, currentModule, true, false)
			if len(matchResults) > 0 {
				w("%s = %s", strings.Join(matchResults, ", "), strings.Join(res, ", "))
			}

			w("\n")
		}

		w("}\n")

		if returnIfTerminal {
			w("return %s\n", strings.Join(matchResults, ", "))
			return nil
		} else {
			return matchResults
		}
	case "parenthesized_expression":
		return p.parseExpr(expr.NamedChild(0), expectedType, currentModule, statement, returnIfTerminal)
	case "product_expression":
		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		utils.Assert(expectedType.Cardinality() > 0, "surely we can't have a product type with zero elements?")
		results := resultVars(expectedType.Cardinality())
		if returnIfTerminal {
			w("return ")
		} else if statement {
			w("%s := ", strings.Join(results, ", "))
		}

		var tup ocaml.Tuple
		switch t := expectedType.(type) {
		case ocaml.Tuple:
			tup = t
		case ocaml.Alias:
			tup = t.Type.(ocaml.Tuple)
		default:
			exitWithError("unexpected type in product_expression: %s", expectedType)
		}

		p.parseExpr(left, tup[:len(tup)-1], currentModule, false, false)
		w(", ")
		p.parseExpr(right, tup[len(tup)-1], currentModule, false, false)

		if statement {
			w("\n")
			if returnIfTerminal {
				return nil
			} else {
				return results
			}
		}
	case "record_expression":
		w("nil /* TODO: record_expression */")
	case "sequence_expression":
		if !statement {
			exitWithError("cannot use sequence_expression as an expression")
		}

		left := expr.ChildByFieldName("left")
		right := expr.ChildByFieldName("right")

		leftRes := p.parseExpr(left, nil, currentModule, true, false)
		ignores := make([]string, len(leftRes))
		for i := range len(leftRes) {
			ignores[i] = "_"
		}
		if len(ignores) > 0 {
			w("%s = %s\n", strings.Join(ignores, ", "), strings.Join(leftRes, ", "))
		}

		rightRes := p.parseExpr(right, expectedType, currentModule, true, returnIfTerminal)
		w("\n")

		return rightRes
	case "sign_expression":
		w("%s(", p.s(expr.ChildByFieldName("operator")))
		p.parseExpr(expr.ChildByFieldName("right"), expectedType, currentModule, false, false)
		w(")")
	default:
		fmt.Fprintf(os.Stderr, "%s\n", p.s(expr))
		fmt.Fprintf(os.Stderr, "%s\n", expr.ToSexp())
		exitWithError("unknown expression type %s", expr.GrammarName())
	}

	return nil
}

// You are expected to write the start of the if case before calling this,
// e.g. "if " or "} else if ".
func (p *ocamlParse) parseMatchPattern(
	pattern *tree_sitter.Node,
	matchVar string,
	guard *tree_sitter.Node,
) {
	switch pattern.GrammarName() {
	case "_lowercase_identifier":
		p.parseExpr(pattern, nil, "", false, false)
		w(" := %s; ", matchVar)
		if guard == nil {
			w("true")
		} else {
			p.parseExpr(guard, ocaml.SimpleType("bool"), "", false, false)
		}
		w(" {\n")

		// Ignore in case it is unused
		w("_ = ")
		p.parseExpr(pattern, nil, "", false, false)
		w("\n")
	case "number", "signed_number":
		w("%s == ", matchVar)
		p.parseExpr(pattern, nil, "", false, false)
		utils.Assert(guard == nil, "expected no guard")
		w(" {\n")
	case "alias_pattern":
		p.parseMatchPattern(pattern.NamedChild(0), matchVar, nil)
		p.parseExpr(pattern.NamedChild(1), nil, "", false, false)
		w(" := %s\n", matchVar)
		utils.Assert(guard == nil, "expected no guard")
	case "constructor_pattern":
		// We only handle Some and None.
		switch p.s(pattern.NamedChild(0)) {
		case "Some":
			p.parseExpr(pattern.NamedChild(1), nil, "", false, false)
			w(" := __derefIfNotNil(%s); %s != nil ", matchVar, matchVar)
			if guard != nil {
				w("&& (")
				p.parseExpr(guard, ocaml.SimpleType("bool"), "", false, false)
				w(") ")
			}
			w("{\n")
		case "None":
			w("%s == nil {\n", matchVar)
		default:
			exitWithError("unknown constructor in match case: %s", pattern.GrammarName())
		}
	case "or_pattern":
		for i, orValue := range flattenOrPattern(pattern) {
			if i > 0 {
				w("||")
			}
			w("%s == ", matchVar)
			p.parseExpr(orValue, nil, "", false, false)
		}
		w(" {\n")
		utils.Assert(guard == nil, "expected no guard")
	default:
		exitWithError("unknown type of match case: %s", pattern.GrammarName())
	}
}

func flattenOrPattern(p *tree_sitter.Node) []*tree_sitter.Node {
	switch p.GrammarName() {
	case "or_pattern":
		var res []*tree_sitter.Node
		res = append(res, flattenOrPattern(p.NamedChild(0))...)
		res = append(res, flattenOrPattern(p.NamedChild(1))...)
		return res
	case "parenthesized_pattern":
		return flattenOrPattern(p.NamedChild(0))
	default:
		return []*tree_sitter.Node{p}
	}
}

func w(msg string, args ...any) {
	fmt.Fprintf(outFile, msg, args...)
}

func tmpVar() string {
	tmpCount += 1
	return fmt.Sprintf("__tmp%d", tmpCount)
}

func resultVars(n int) []string {
	vars := make([]string, n)
	for i := range n {
		vars[i] = tmpVar()
	}
	return vars
}

func parseHoverResponse(hover ocaml.M) ocaml.Type {
	value := hover["contents"].(ocaml.M)["value"].(string)
	value = strings.SplitN(value, "***", 2)[0]
	return ocaml.ParseType(value, typeDefs)
}

func (p *ocamlParse) getTypeStart(node *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	hover := utils.Must1(lspClient.Hover(
		p.filepath,
		int(node.StartPosition().Row),
		int(node.StartPosition().Column),
	))
	return parseHoverResponse(hover)
}

func (p *ocamlParse) getTypeEnd(node *tree_sitter.Node, typeDefs map[string]ocaml.Type) ocaml.Type {
	hover := utils.Must1(lspClient.Hover(
		p.filepath,
		int(node.EndPosition().Row),
		int(node.EndPosition().Column),
	))
	return parseHoverResponse(hover)
}

func exitWithError(msg string, args ...any) {
	msg = fmt.Sprintf(msg, args...)
	panic(fmt.Sprintf("ERROR: %s\n", msg))
}

type Lookup struct {
	Node *tree_sitter.Node
}

func (l Lookup) Child(i uint, grammarName string) Lookup {
	node := l.Node.NamedChild(i)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}

func (l Lookup) Field(fieldName string, grammarName string) Lookup {
	node := l.Node.ChildByFieldName(fieldName)
	if grammarName != "" {
		utils.Assert(node.GrammarName() == grammarName, "expected %s but got %s", grammarName, node.GrammarName())
	}
	return Lookup{node}
}
